# 어렵게 막 묶음 이런거 계산하고 그럴게 아니라,
# 모든 숫자를 전부 같게 만드는 것이 목적. 이라는 것에 집중하자.
# 그럼, 전부 0으로 만드는 경우. 그리고 전부 1로 만드는 경우
# 이렇게 두 가지 경우가 있다. 그 경우를 각각 고려하여, Min 을 구하면 되는 문제
# 연속된 숫자들을 뒤집는 것이므로, 결국 0에서 1로 바뀌거나 1에서 0으로 바뀌는 부분을 찾아야 함.

# 문자열을 앞에서부터 순차적으로 탐색하면서, '0'에서 '1'로 또는 '1'에서 '0'으로 바뀌는 지점의 수를 각각 세면 됩니다. 
# 이 때, '0'에서 '1'로 바뀌는 경우와 '1'에서 '0'으로 바뀌는 경우 중 더 작은 횟수를 가진 경우가 전체 문자열을 같은 숫자로 만들기 위해 뒤집어야 하는 최소 횟수가 됩니다.


S = input()

# 0 에서 1로 바뀌는 경우와 1에서 0으로 바뀌는 경우의 수를 세기 위한 변수 초기화
cnt_to_1 = 0
cnt_to_0 = 0

# 첫 번째 문자에 따라 초기 카운트 값을 설정
if S[0] == '1':
    cnt_to_0 += 1
else:
    cnt_to_1 += 1

# 문자열을 순회하며, 변화하는 지점을 카운트
for i in range(len(S) - 1):
    if S[i] != S[i + 1]:
        # '0' 에서 '1' 로 바뀌는 경우
        if S[i + 1] == '1':
            cnt_to_1 += 1
        else:
            cnt_to_0 += 1

print(min(cnt_to_0, cnt_to_1))